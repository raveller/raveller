<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hit or Miss - Classic Arcade Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            color: #00ff00;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ff00;
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            border: 2px solid #00ff00;
            background-color: #001122;
            margin: 20px auto;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #scorePanel {
            position: absolute;
            left: 10px;
            top: 10px;
            color: #00ffff;
            font-size: 16px;
            line-height: 1.5;
        }

        #highScorePanel {
            position: absolute;
            left: 10px;
            top: 120px;
            color: #00ff00;
            font-size: 16px;
            line-height: 1.5;
        }

        #instructions {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffff00;
            font-size: 14px;
            text-align: center;
        }

        #startMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 18px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #ffffff;
        }

        #gameOverMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 18px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #ff0000;
            display: none;
        }

        .button {
            background-color: #004400;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }

        .button:hover {
            background-color: #006600;
        }

        .status-bar {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 20px;
            color: #ffff00;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>HIT OR MISS</h1>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="scorePanel">
            <div>YOUR</div>
            <div>SCORE:</div>
            <div id="currentScore">0</div>
        </div>
        
        <div id="highScorePanel">
            <div>HIGH</div>
            <div>SCORE:</div>
            <div id="highScore">0</div>
        </div>
        
        <div id="instructions">
            PADDLE KEYS: A/B/← = LEFT | D/N/→ = RIGHT
        </div>
        
        <div id="startMessage">
            <div>PRESS SPACE TO BEGIN</div>
        </div>
        
        <div id="gameOverMessage">
            <div id="gameOverText"></div>
            <button class="button" onclick="startGame()">REPLAY</button>
            <button class="button" onclick="location.reload()">QUIT</button>
        </div>
        
        <div class="status-bar" id="statusBar"></div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Field boundaries (shared across functions)
        const leftWall = 150;
        const rightWall = 654; // 150 + (28 * 18)
        
        let gameState = 'waiting'; // 'waiting', 'playing', 'gameOver'
        let score = 0;
        let highScore = localStorage.getItem('hitormiss-highscore') || 0;
        let hitMissFlag = false; // false = top is HIT, bottom is MISS; true = reversed
        
        // Ball properties (character-based like original)
        let ball = {
            x: 400,
            y: 300,
            dx: 3,
            dy: 3,
            char: '●',
            color: '#ffffff',
            lastRowConsumed: -1, // Track last row where block was consumed
            gridX: 0, // Grid position
            gridY: 0
        };
        
        // Paddle properties (6-character wide string)
        let paddle = {
            x: 350,
            y: 290, // Middle of screen
            gridX: 0, // Grid position
            width: 6, // 6 characters wide
            chars: '======',
            color: '#ffffff',
            backgroundColor: '#ffff00',
            speed: 18 // Move by character width
        };
        
        // Field obstacles
        let obstacles = [];
        
        // Input handling
        let keys = {};
        
        // Initialize the game
        function init() {
            document.getElementById('highScore').textContent = highScore;
            createObstacles();
            setupEventListeners();
            gameLoop();
        }
        
        function createObstacles() {
            obstacles = [];
            
            // Create the structured field pattern like the original BASIC game
            // Field extends from just below HIT zone to just above MISS zone
            // + blocks are centered in the field
            
            let startY = 50; // Start just below HIT zone
            let endY = 550;  // End just above MISS zone
            let rowHeight = 20;
            let charWidth = 18;
            let startX = leftWall; // Align with wall boundaries
            
            for (let y = startY; y < endY; y += rowHeight) {
                // Skip the paddle row area
                if (y > 280 && y < 310) continue;
                
                for (let col = 0; col < 28; col++) {
                    let x = startX + (col * charWidth);
                    
                    // Center the + blocks: positions 12-15 (4 blocks in center to align with "H I T !")
                    let isDeflector = (col >= 12 && col <= 15);
                    
                    obstacles.push({
                        x: x,
                        y: y,
                        width: 16,
                        height: 16,
                        type: isDeflector ? 'deflector' : 'passthrough',
                        char: isDeflector ? '+' : '*',
                        color: isDeflector ? '#ffff00' : '#00ffff',
                        points: isDeflector ? 20 : 500, // * gives more points like original
                        consumed: false
                    });
                }
            }
        }
        
        function setupEventListeners() {
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                if (e.key === ' ' && gameState === 'waiting') {
                    startGame();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
        }
        
        function startGame() {
            gameState = 'playing';
            score = 0;
            hitMissFlag = false; // Always start with HIT at top, MISS at bottom
            
            // Reset ball position - start just above paddle
            ball.x = Math.random() * 400 + 200; // Start somewhere above paddle
            ball.y = 250; // Just above paddle area
            ball.dx = 18; // Move by character width (45-degree movement)
            ball.dy = -20; // Move by row height
            ball.lastRowConsumed = -1; // Reset consumption tracking
            
            // Update ball grid position
            ball.gridX = Math.floor((ball.x - leftWall) / 18);
            ball.gridY = Math.floor((ball.y - 50) / 20);
            
            // Reset paddle to center
            paddle.gridX = 11; // Center in 28-character field
            paddle.x = leftWall + (paddle.gridX * 18);
            
            // Hide start message
            document.getElementById('startMessage').style.display = 'none';
            document.getElementById('gameOverMessage').style.display = 'none';
            
            // Recreate obstacles
            createObstacles();
        }
        
        function update() {
            if (gameState !== 'playing') return;
            
            // Update paddle position (move by character positions)
            if ((keys['a'] || keys['b'] || keys['arrowleft']) && paddle.gridX > 0) {
                paddle.gridX -= 1;
                paddle.x = leftWall + (paddle.gridX * 18);
            }
            if ((keys['d'] || keys['n'] || keys['arrowright']) && paddle.gridX < 28 - paddle.width) {
                paddle.gridX += 1;
                paddle.x = leftWall + (paddle.gridX * 18);
            }
            
            // Update ball position (character-based movement - slowed to every 6 frames)
            // Move every 6th frame to slow down the ball
            if (!ball.moveCounter) ball.moveCounter = 0;
            ball.moveCounter++;
            
            let ballMoved = false;
            if (ball.moveCounter >= 6) {
                ball.x += ball.dx;
                ball.y += ball.dy;
                ball.moveCounter = 0;
                ballMoved = true;
                
                // Update ball grid position
                ball.gridX = Math.floor((ball.x - leftWall) / 18);
                ball.gridY = Math.floor((ball.y - 50) / 20);
            }
            
            // Only check hit/miss zones and collisions when ball actually moved
            if (!ballMoved) {
                return; // Skip collision detection if ball didn't move this frame
            }
            
            // Ball collision with side walls (character-based)
            if (ball.gridX <= 0 || ball.gridX >= 27) {
                ball.dx = -ball.dx; // Reverse horizontal direction
                // Maintain 45-degree angle by keeping dy unchanged
                ball.x = Math.max(leftWall, Math.min(ball.x, leftWall + (27 * 18)));
                ball.gridX = Math.floor((ball.x - leftWall) / 18); // Update grid position
                playSound(100, 100);
            }
            
            // Check hit/miss zones at top and bottom (aligned with block field)
            if (ball.y <= 50) { // Top zone - just above blocks
                if (!hitMissFlag) { // Top is HIT zone
                    // Hit the HIT zone
                    ball.dy = Math.abs(ball.dy); // Bounce down
                    score += 50;
                    playSound(400, 100);
                    
                    // Randomly switch zones after hitting HIT zone (70% chance to switch)
                    if (Math.random() > 0.3) {
                        hitMissFlag = !hitMissFlag;
                        playSound(800, 200);
                    }
                } else {
                    // Hit the MISS zone
                    gameOver();
                    return;
                }
            }
            
            if (ball.y >= 550) { // Bottom zone - just below blocks
                if (hitMissFlag) { // Bottom is HIT zone (when flag is true)
                    // Hit the HIT zone
                    ball.dy = -Math.abs(ball.dy); // Bounce up
                    score += 50;
                    playSound(400, 100);
                    
                    // Randomly switch zones after hitting HIT zone (70% chance to switch)
                    if (Math.random() > 0.3) {
                        hitMissFlag = !hitMissFlag;
                        playSound(800, 200);
                    }
                } else {
                    // Hit the MISS zone
                    gameOver();
                    return;
                }
            }
            
            // Ball collision with paddle (character-based)
            let paddleRow = Math.floor((paddle.y - 50) / 20);
            if (ball.gridY === paddleRow && 
                ball.gridX >= paddle.gridX && 
                ball.gridX < paddle.gridX + paddle.width) {
                
                // Bounce off paddle
                ball.dy = -Math.abs(ball.dy); // Always bounce up
                ball.y = paddle.y - 20; // Position above paddle
                
                playSound(200, 50);
            }
            
            // Ball collision with obstacles (character-based)
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obstacle = obstacles[i];
                
                // Skip if already consumed
                if (obstacle.consumed) continue;
                
                // Calculate obstacle grid position
                let obstacleGridX = Math.floor((obstacle.x - leftWall) / 18);
                let obstacleGridY = Math.floor((obstacle.y - 50) / 20);
                
                // Check if ball is at same grid position as obstacle
                if (ball.gridX === obstacleGridX && ball.gridY === obstacleGridY) {
                    
                    if (obstacle.type === 'deflector') {
                        // Plus sign - deflects horizontally and gets consumed
                        ball.dx = -ball.dx;
                        
                        score += obstacle.points;
                        obstacle.consumed = true;
                        ball.lastRowConsumed = obstacleGridY;
                        playSound(300, 50);
                        updateScore();
                        break;
                    } else {
                        // Asterisk - passthrough, awards points, gets consumed
                        // Only consume if we haven't consumed a block in this row yet
                        if (ball.lastRowConsumed !== obstacleGridY) {
                            score += obstacle.points;
                            obstacle.consumed = true;
                            ball.lastRowConsumed = obstacleGridY;
                            playSound(550, 30);
                            updateScore();
                            break; // Only consume one block per row movement
                        }
                    }
                }
            }
            
            updateScore();
        }
        
        function updateScore() {
            document.getElementById('currentScore').textContent = score;
        }
        
        function gameOver() {
            gameState = 'gameOver';
            
            // Update high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('hitormiss-highscore', highScore);
                document.getElementById('highScore').textContent = highScore;
            }
            
            // Show game over message
            let gameOverText = `SORRY, YOU MISSED.\n\nYOUR SCORE WAS ${score} POINTS.\n`;
            if (score > localStorage.getItem('hitormiss-previous-high') || 0) {
                gameOverText += 'A NEW RECORD!\n';
            }
            gameOverText += `THE HIGH SCORE IS ${highScore} POINTS.`;
            
            document.getElementById('gameOverText').innerHTML = gameOverText.replace(/\n/g, '<br>');
            document.getElementById('gameOverMessage').style.display = 'block';
            
            // Play game over sound sequence
            playGameOverSound();
        }
        
        function render() {
            // Clear canvas
            ctx.fillStyle = '#001122';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw hit/miss zones (aligned with block field)
            ctx.font = '16px monospace';
            ctx.textAlign = 'left';
            
            // Create the hit/miss bars that align with the block structure
            // Each character should align with the 18px width blocks
            let hitBar = '';
            let missBar = '';
            
            for (let col = 0; col < 28; col++) {
                if (col >= 11 && col <= 16) {
                    // Center area - show text
                    if (col === 11) {
                        hitBar += ' HIT! ';
                        missBar += ' MISS ';
                    }
                    // Skip the remaining center columns as text spans multiple columns
                } else {
                    // Outer areas - show symbols aligned with * blocks
                    hitBar += '=';
                    missBar += '/';
                }
            }
            
            // Draw each character positioned to match the block grid
            let charWidth = 18;
            
            // Top zone (just above block field)
            ctx.fillStyle = !hitMissFlag ? '#00ff00' : '#ff0000';
            for (let col = 0; col < 28; col++) {
                let x = leftWall + (col * charWidth);
                if (col >= 12 && col <= 15) {
                    // Center text area - "H I T !" spans 4 characters (cols 12-15) to align with middle 4 + marks
                    if (col === 12) {
                        ctx.fillText(!hitMissFlag ? 'H I T !' : 'M I S S', x, 45);
                    }
                } else {
                    // Symbol characters
                    ctx.fillText(!hitMissFlag ? '=' : '/', x, 45);
                }
            }
            
            // Bottom zone (just below block field)
            ctx.fillStyle = hitMissFlag ? '#00ff00' : '#ff0000';
            for (let col = 0; col < 28; col++) {
                let x = leftWall + (col * charWidth);
                if (col >= 12 && col <= 15) {
                    // Center text area - "H I T !" spans 4 characters (cols 12-15) to align with middle 4 + marks
                    if (col === 12) {
                        ctx.fillText(hitMissFlag ? 'H I T !' : 'M I S S', x, 565);
                    }
                } else {
                    // Symbol characters
                    ctx.fillText(hitMissFlag ? '=' : '/', x, 565);
                }
            }
            
            // Draw field boundaries (walls) - extend to abut the hit/miss bars
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(leftWall, 45);
            ctx.lineTo(leftWall, 565);
            ctx.moveTo(rightWall, 45);
            ctx.lineTo(rightWall, 565);
            ctx.stroke();
            
            // Draw obstacles
            ctx.font = '16px monospace';
            ctx.textAlign = 'center';
            obstacles.forEach(obstacle => {
                // Only draw if not consumed
                if (!obstacle.consumed) {
                    ctx.fillStyle = obstacle.color;
                    ctx.fillText(obstacle.char, obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2 + 6);
                }
            });
            
            // Draw paddle (6-character wide string of highlighted equal signs)
            ctx.font = '16px monospace';
            ctx.textAlign = 'left';
            for (let i = 0; i < paddle.width; i++) {
                let x = paddle.x + (i * 18);
                
                // Draw background highlight
                ctx.fillStyle = paddle.backgroundColor;
                ctx.fillRect(x, paddle.y, 18, 20);
                
                // Draw the equal sign character
                ctx.fillStyle = paddle.color;
                ctx.fillText('=', x + 2, paddle.y + 16);
            }
            
            // Draw ball (character-based)
            ctx.fillStyle = ball.color;
            ctx.fillText(ball.char, ball.x + 2, ball.y + 16);
        }
        
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // Simple sound effect simulation
        function playSound(frequency, duration) {
            // Visual flash effect to simulate sound
            canvas.style.filter = 'brightness(1.3)';
            setTimeout(() => {
                canvas.style.filter = 'brightness(1)';
            }, 50);
        }
        
        function playGameOverSound() {
            // Simulate the game over sound sequence
            let flashes = 0;
            let interval = setInterval(() => {
                canvas.style.filter = flashes % 2 === 0 ? 'brightness(0.5)' : 'brightness(1.5)';
                flashes++;
                if (flashes > 10) {
                    clearInterval(interval);
                    canvas.style.filter = 'brightness(1)';
                }
            }, 200);
        }
        
        // Start the game
        init();
    </script>
</body>
</html>
