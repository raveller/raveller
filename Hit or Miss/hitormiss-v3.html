<!DOCTYPE html>
<!-- saved from url=(0031)https://raveller.net/hitormiss/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hit or Miss - Family Computing July 1985</title>
    <style>
        @font-face {
            font-family: 'square';
            src: url('./square.ttf');
        }

        body {
            margin: 0;
            background: #000;
            color: #fff;
            font-family: square;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameArea {
            width: 690px;
            height: 480px;
            background: #000;
            border: 2px solid #333;
            position: relative;
            font-size: 16px;
            line-height: 20px;
        }
        
        #screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-family: square;
            white-space: pre;
            font-size: 16px;
            line-height: 20px;
        }
        
        .color-2 { color: #f8f; }
        .color-3 { color: #0ff; }
        .color-4 { color: #f00; }
        .color-5 { color: #f0f; }
        .color-7 { color: #fff; }
        .color-10 { color: #0f0; }
        .color-14 { color: #ff0; }
        .color-15 { color: #fff; }
        .color-16 { color: #f00; }
        .color-17 { color: #0f0; }
        .color-18 { color: #00f; }

    </style>
</head>
<body>
    <div id="gameArea">
        <div id="screen">
        </div>
    </div>

    <script>
        // BASIC screen emulation - 40 chars wide, 25 rows
        const SCREEN_WIDTH = 40;
        const SCREEN_HEIGHT = 25;
        let screen = [];
        let screenColors = [];
        
        // Game variables from BASIC
        let HS = 0;  // High score
        let V$ = "|"; // "║";  // Double pipe character for side walls
        let paddleBlock = "-"; //"█; //" // ▄
        let S$ = " ";   // Space
        let L$ = "";
        let B$ = "";
        let M$ = "////////////MISS////////////";
        let H$ = "============HIT!============";
        let Q$ = "O"; "●"; // "@"; // Ball character
        let P$ = "";  // Paddle string (4 solid blocks)
        let N$ = "";  // Paddle erase string (4 spaces)
        let passBlock = "~"; //"□"; // 
        let deflectBlock = "+"; // 
        let bonusBlock = "*";
        
        // Game state variables
        let CX, RX, DC, DR, SC, FL, NP, LP, M;
        let HC, HR;
        let gameRunning = false;
        let waitingForKey = false;
        let firstPlay = true;
        
        var audioContext = new AudioContext();

        // Initialize screen
        function initScreen() {
            screen = [];
            screenColors = [];
            for (let row = 0; row < SCREEN_HEIGHT; row++) {
                screen[row] = [];
                screenColors[row] = [];
                for (let col = 0; col < SCREEN_WIDTH; col++) {
                    screen[row][col] = ' ';
                    screenColors[row][col] = 7;
                }
            }
        }
        
        // BASIC emulation functions
        function CLS() {
            initScreen();
            LOCATE(1, 1);
        }
        
        function LOCATE(row, col) {
            // Convert to 0-based indexing
            currentRow = row - 1;
            currentCol = col - 1;
        }
        
        function PRINT(text, color = 7) {
            if (typeof text === 'undefined') text = '';
            let str = String(text);
            for (let i = 0; i < str.length; i++) {
                if (currentCol < SCREEN_WIDTH && currentRow < SCREEN_HEIGHT) {
                    screen[currentRow][currentCol] = str[i];
                    screenColors[currentRow][currentCol] = color;
                    currentCol++;
                }
            }
        }
        
        function SCREEN_READ(row, col) {
            if (row >= 1 && row <= SCREEN_HEIGHT && col >= 1 && col <= SCREEN_WIDTH) {
                return screen[row - 1][col - 1];
            }
            return " "; // Space
        }

        function doubleBeep(frequency, durationMs, frequency2, durationMs2) {
           
            var oscillator1 = audioContext.createOscillator();
            oscillator1.type = "sine";
            oscillator1.frequency.value = frequency;
            oscillator1.connect(audioContext.destination);
            oscillator1.start();
            // Beep for 100 milliseconds
            setTimeout(function () {
                oscillator1.stop();
                if (durationMs2 < 1) { return; }

                beep(frequency2, durationMs2);
            }, durationMs);
        }

        function beep(frequency, durationMs) {            
            var oscillator2 = audioContext.createOscillator();
            oscillator2.type = "sine";
            oscillator2.frequency.value = frequency;
            oscillator2.connect(audioContext.destination);
            oscillator2.start();
            // Beep for 100 milliseconds
            setTimeout(function () {
                oscillator2.stop();
            }, durationMs);
            return true;
        }

        function RND() {
            return Math.random();
        }
        
        function INT(x) {
            return Math.floor(x);
        }
        
        let currentRow = 0;
        let currentCol = 0;
        
        // Render screen to HTML
        function renderScreen() {
            let html = '';
            for (let row = 0; row < SCREEN_HEIGHT; row++) {
                for (let col = 0; col < SCREEN_WIDTH; col++) {
                    let char = screen[row][col];
                    let color = screenColors[row][col];
                    html += `<span class="color-${color}">${char === ' ' ? '&nbsp;' : char}</span>`;
                }
                html += '\n';
            }
            document.getElementById('screen').innerHTML = html;
        }
        
        // Initialize game variables (lines 20-80)
        function initGame() {
            HS = parseInt(localStorage.getItem('hitormiss-hs')) || 0;
            
            // Build L$ string (line 30)
            L$ = S$;
            for (let X = 1; X <= 22; X++) {
                L$ += S$;
            }
            
            // Build B$ string (lines 40-50)
            B$ = "";
            for (let X = 1; X <= 28; X++) {
                let block = passBlock;
                if (X >= 13 && X <= 16)
                    block = deflectBlock;
                B$ += block
            }
            
            // Initialize paddle strings (line 80)
            P$ = "";
            N$ = "";
            for (let i = 0; i < 4; i++) {
                P$ += paddleBlock; // More visible solid block
                N$ += " ";  // Space
            }
        }
        
        // Initialize ball position (line 90)
        function initBall() {
            do {
                CX = INT(RND() * 25) + 9;
            } while (CX > 20 && CX < 25);
            
            FL = -1;
            DR = -1;
            DC = -1;
            SC = 0;
            RX = 11;
            
            HC = CX;
            HR = RX;
            NP = 21;
            LP = 19;
            M = 0;
        }
        
        // Draw initial screen (lines 120-230)
        function drawInitialScreen() {
            CLS();
            
            // Score display (lines 130-140)
            LOCATE(6, 1);
            PRINT("YOUR", 3);
            LOCATE(7, 1);
            PRINT("SCORE:", 3);
            LOCATE(9, 1);
            PRINT(SC, 3);
            
            LOCATE(13, 1);
            PRINT("HIGH", 10);
            LOCATE(14, 1);
            PRINT("SCORE:", 10);
            LOCATE(16, 1);
            PRINT(HS, 10);
            
            // Draw game field (lines 150-190)
            let KO = 3;
            for (let X = 2; X <= 20; X++) {
                LOCATE(X, 8);
                PRINT(V$, 5);
                
                if (X > 9 && X < 13) {
                    // Paddle area - just spaces and right border
                    for (let i = 0; i < 28; i++) {
                        PRINT(" ");
                    }
                    PRINT(V$, 5);
                } else {
                    // Barrier area
                    PRINT(B$, KO);
                    PRINT(V$, 5);
                }
                
                if (X === 12) KO = 2;
            }
            
            // Instructions (lines 200-220)
            LOCATE(11, 13);
            PRINT("PRESS SPACE TO BEGIN.", 15);
            LOCATE(23, 17);
            PRINT("PADDLE KEYS:", 7);
            LOCATE(24, 9);
            PRINT("←,B,A = LEFT   D,N,→ = RIGHT", 7);

            // Initial hit/miss zones (GOSUB 1030)
            drawHitMissZones(false);
            
            renderScreen();
        }
        
        // Draw hit/miss zones (lines 1000-1040)
        function drawHitMissZones(switched) {
            if (!switched) {
                // Normal: HIT at top, MISS at bottom
                LOCATE(1, 8);
                PRINT(V$, 5);
                PRINT(H$, 14);
                PRINT(V$, 5);
                
                LOCATE(21, 8);
                PRINT(V$, 5);
                PRINT(M$, 4);
                PRINT(V$, 5);
            } else {
                // Switched: MISS at top, HIT at bottom
                LOCATE(1, 8);
                PRINT(V$, 5);
                PRINT(M$, 4);
                PRINT(V$, 5);
                
                LOCATE(21, 8);
                PRINT(V$, 5);
                PRINT(H$, 14);
                PRINT(V$, 5);
            }
        }
        
        // Main game loop (lines 240-560)
        function gameLoop() {
            if (!gameRunning) return;
            
            // Update paddle position based on held keys
            updatePaddle();
            
            // Random target spawning (lines 260-300)
            if (RND() <= 0.05) {
                let randomBlock = bonusBlock; // Asterisk
                if (M > 300 && RND() > 0.5) {
                    randomBlock = deflectBlock; // Plus
                }
                
                let XR;
                do {
                    XR = INT(RND() * 16) + 3;
                } while (XR > 9 && XR < 13);
                
                let YR = INT(RND() * 21) + 10;
                LOCATE(XR, YR);
                PRINT(randomBlock, 7);
            }

            pCX = CX;
            pRX = RX;
            
            // Ball movement (line 310)
            CX += DC;
            RX += DR;
            
            // Check what ball hit (line 320)
            let PE = SCREEN_READ(RX, CX);
            
            let beeped = false;

            // Handle collisions (lines 330-350)
            if (PE === passBlock || PE === deflectBlock) { // Plus or O
                SC += 20;
                M += 1;
                updateScore();
            }
            if (PE === bonusBlock) { // Asterisk
                SC += 500;                
                if (!beeped) { beeped = beep(350, 50); }
                updateScore();
            }
            if (PE === deflectBlock) { // Plus deflects
                DC = -DC;
            }
            
            // Wall collisions (lines 360-380)
            if (CX <= 8 || CX >= 37) {
                DC = -DC;
                CX += DC;             
                if (!beeped) { beep(100, 50) };
                // Re-check what ball hit after bounce
                PE = SCREEN_READ(RX, CX);
            }
            
            // PADDLE COLLISION
            if (PE == paddleBlock) {
                DR = -DR;
                RX=RX+2*DR;
                if (!beeped) { beep(200, 50) }; 
            } 

            let switched = false;
            // TOP BOTTOM COLLISIONS (lines 390-450)
            if (RX <= 1 || RX >= 21) {
                DR = -DR;

                if (RX < 2) {
                    RX = 2;
                    if (FL === 0) { // Hit miss zone
                        gameOver();
                        return;
                    }
                } else if (RX > 20) {
                    RX = 20;
                    if (FL !== 0) { // Hit miss zone
                        gameOver();
                        return;
                    }
                }

                switched = switchZones();
                if (switched) {                    
                    doubleBeep(800, 100, 600, 100); 
                }
                else {
                    beep(200, 50); 
                }
                SC += M;
                updateScore();
            }
            
            // Erase old ball position (line 460)
            PE = SCREEN_READ(pRX, pCX);

            LOCATE(pRX, pCX);
            if (PE != paddleBlock) // Don't erase paddle
                PRINT(S$);
            
            // Draw new ball position (line 470)
            LOCATE(RX, CX);
            PRINT(Q$, 15);
            
            HC = CX;
            HR = RX;
            
            renderScreen();
            
            // Continue game loop
            setTimeout(gameLoop, switched ? 300 : 100); // Slow down game speed, pause a bit longer if zones switched
        }

        function switchZones() {
            if (RND() <= 0.7) {
                return false;
            }

            FL = FL === 0 ? -1 : 0;
            drawHitMissZones(FL === 0);
            doubleBeep(800, 100, 600, 100); 
            return true;
        }

        
        // Update score display
        function updateScore() {
            LOCATE(9, 1)
            PRINT("       "); // Add spaces to clear old score
            LOCATE(9, 1);            
            PRINT(SC, 3); // Add spaces to clear old score
        }
        
        // Handle paddle movement (lines 490-560)
        let keys = {}; // Track which keys are currently pressed
        
        function handleInput() {
            // Track key press and release
            document.addEventListener('keydown', (e) => {
                let key = e.key.toUpperCase();
                keys[key] = true;
                
                if (waitingForKey && key == ' ') {
                    if (firstPlay) {
                        // Resume audio context on first user interaction
                        beep(200, 50);
                    }
                    firstPlay = false;

                    // Start game
                    waitingForKey = false;
                    gameRunning = true;
                    LOCATE(11, 12);
                    PRINT(L$);
                    
                    // Redraw paddle after clearing start text
                    LOCATE(11, NP);
                    PRINT(P$, 15);
                    
                    renderScreen();

                    setTimeout(doubleBeep(200, 50, 400, 50), 50); // Initial beep to enable audio on some browsers
                    setTimeout(gameLoop(), 50);
                    return;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                let key = e.key.toUpperCase();
                keys[key] = false;
            });
        }
        
        function updatePaddle() {
            if (!gameRunning) return;
            
            let oldNP = NP;
            
            // Continuous movement while keys are held
            if (keys['B'] || keys['A'] || keys['ARROWLEFT']) NP -= 2;
            if (keys['N'] || keys['D'] || keys['ARROWRIGHT']) NP += 2;
            
            if (oldNP !== NP) {
                // Constrain paddle position
                if (NP < 9) NP = 9;
                if (NP > 33) NP = 33;
                
                // Erase old paddle
                LOCATE(11, oldNP);
                PRINT(N$);
                
                // Draw new paddle
                LOCATE(11, NP);
                PRINT(P$, 15);
                
                LP = NP;
            }
        }
        
        // Game over sequence (lines 570-690)
        function gameOver() {
            gameRunning = false;
            
            // Game over effects (lines 570-590)
            let flashes = 0;
            let flashInterval = setInterval(() => {
                LOCATE(HR, HC);
                var color = flashes % 3 + 16; // Cycle through colors 16, 17, 18
                switch (flashes % 4) {
                    case 0:
                        PRINT("@", color);
                        break;
                    case 1:
                        PRINT("/", color);
                        break;
                    case 2:
                        PRINT("-", color);
                        break;
                    case 3:
                        PRINT("\\", color);
                        break;
                }
                renderScreen();
                beep(20 * (50 - flashes), 40);
                flashes++;
                if (flashes >= 45) {
                    clearInterval(flashInterval);
                    showGameOverScreen();
                }
            }, 50);
        }
        
        function showGameOverScreen() {
            for (let j = 10; j < 13; j++) {
                LOCATE(j, 9);
                for (let i = 0; i < 28; i++) {
                    PRINT(" ");
                }
            }
            LOCATE(10, SC > 10000 ? 11 : 12);
            PRINT()
            PRINT("YOU SCORED " + SC + " POINTS!");
            
            if (SC > HS) {
                HS = SC;
                localStorage.setItem('hitormiss-hs', HS);
                LOCATE(11, 16);
                PRINT("A NEW RECORD!", 14);
            }
            renderScreen();

            // Show restart options
            setTimeout(() => {
                LOCATE(12, 13);
                PRINT("PRESS SPACE TO RESET", 17);
                
                renderScreen();
                setupRestartKeys();
            }, 2000);
        }
        
        function setupRestartKeys() {
            function restartHandler(e) {                
                if (!keys[' ']) { return; }
                document.removeEventListener('keydown', restartHandler);
                startNewGame();
            }
            document.addEventListener('keydown', restartHandler);
        }
        
        function startNewGame() {
            initBall();
            drawInitialScreen();
            waitingForKey = true;
        }
        
        // Initialize and start
        function init() {
            initGame();
            initScreen();
            handleInput();
            startNewGame();
        }
        
        // Start the game
        window.onload = init;
    </script>


</body></html>